#### Principle of this programm #####
# In this programm, I simulate the evolution of two populations of bacteria living together in a mammalian gut as in the "2strains_4colors.py" program,
# except this time selective advantage is chosen for each mutation in a gamma law of mean s and shape k (variance s^2/k)
# Each population has the same initial fitess, the same mutation rate, and all mutations are beneficial as previously
#



##### Imports #####

import csv  # for output export
import numpy as np  # to have access to random laws for 
import os  # to create directories
import time as t  # to measure the duration of one simulation
import argparse  # to collect the arguments given by the user


t0=t.time()


##### Retrieving and setting parameters #####

# create the option parser
parser = argparse.ArgumentParser(description='Simulation of coexistence of 2 similar invading strains with 2 similar resident strains (each labelled with a different color)')

# add options to the parser
parser.add_argument('-u', '--mut', type=float, default=1e-7, help='Mutation rate per individual bacteria')
parser.add_argument('-s', '--sel', type=float, default=0.01, help='Mean selective advantage given by a mutation')
parser.add_argument('-k', '--shape', type=float, default=1, help='The shape of the Gamma law in which the mutational effect is drawn')
parser.add_argument('-N', '--Ntot', type=float, default=1e6, help='Total polulation (constant)')
parser.add_argument('-r', '--rep', type=int, default=1, help='Index of the replica when simulating several times with the same parameters')
parser.add_argument('-p', '--prop', type=float, default=0.1, help='Initial proportion of the invading strain in the total population')
parser.add_argument('-g', '--N_generation', type=int, default=1600, help='Number of generations run in one simulation')
parser.add_argument('-f', '--folder', type=str, default="\Simuls\Gamma", help='The folder where to put the simulated CSV files')


# parse the options
args = parser.parse_args()

u = args.mut  # mutation rate
s = args.sel  # mean selective advantage
k = int(args.shape)  # s = k*theta is the mean of Gamma distribution of shape k and scale theta. Here we give s and k so theta := s/k. k=1 corresponds to exponential distribution
# theta=1 (s=k) corresponds to standard Gamma distribution (SGD), and with theta!=1 the law simulated is the same as theta*SGD = (s/k)*SGD. So higher k means less spread distribution
# Note that changing k without changing s means changing both k and theta
theta = s/k
N_tot = int(args.Ntot)  # total population
rep = args.rep  # replica number (to name the output files)
p = args.prop  # initial proportion of invaders (0.1 by default)
N_generation = args.N_generation  # number of generations (1600 by default)
folder = args.folder  # folder to put the output files in ; Simuls folder by default, you have to create it before running the code

# path to your current working directory
path = os.getcwd()

## Put N_tot into concise format
formatted_num = "{:.0e}".format(N_tot)
mantissa, exponent = formatted_num.split("e")
N_to_print = "{}e{}".format(mantissa, int(exponent)) # for instance, 1000000 will now appear as "1e6" in the name of the output


print("Arguments : \n  mutation rate : {} \n selective advantage {} \n total population : {} \n  replica number {}".format(u,s,N_to_print,rep))


## Fixed parameters
t_sample = 200

cols = ["B", "Y", "G", "R"]   # Blue, Yellow, Green, Red, first the two from the invading strain, then the two from the residing strain




##### Output directory and filenames #####
# Directory to put the different replicas with the same parameters
dir_name = "/Multi_Gamma_u"+str(u)+"_s"+str(s)+"_k"+str(k)+"_Ntot"+N_to_print+"_p"+str(p)
if not os.path.exists(path+folder+dir_name) :
    os.mkdir(path+folder+dir_name) # create the directory where the directories of each replicates will be put in for the current set of parameters


# Directory with the 4 files generated by one simulation
final_name = dir_name+"_rep"+str(rep)
if not os.path.exists(path+folder+dir_name+final_name) :
    os.mkdir(path+folder+dir_name+final_name) # create the directory where the output files will be put in for the current set of parameters for this replica



##### Initialisation #####

# keep a track of the population of each 4 colors of bacteria
in_numbers = [round((N_tot*p))//2, round(N_tot*p)//2, round(N_tot*(1-p))//2, round(N_tot*(1-p))//2] # initial number of each bacterial color
if sum(in_numbers) != int(N_tot) :  # fixing "rounding" errors 
    print(in_numbers)
    if p<0.5 :
        while sum(in_numbers) != int(N_tot) :
            in_numbers[0] += 1
            in_numbers[1] += 1
    else :
        while sum(in_numbers) != int(N_tot) :
            in_numbers[2] += 1
            in_numbers[3] += 1
    print(in_numbers)


# "numbers" is a list of length 4 with the current population size of each color (all substrains confounded), that is updated every generation
numbers = in_numbers  # initial populations at generation 0


# Arrays with the fitness of each substrain and its number of individuals in the total population
fit_values = [[1],[1],[1],[1]]  # list of 4 sublists (for the 4 colors). Each sublist stores the fitness of the current living substrains (we can no longer use the number of mutations to compute it)
freqs = []
for i in range(4) :
    freqs.append([in_numbers[i]]) # list of 4 sublists (for the 4 colors). Each sublist stores the population size of each substrain currently alive
    # we rely on the order of each sublist to match the population size of each substrains with its correct fitness
    # it stores integers (population number of each substrain) but you can get the frequency of substrain i by freqs[i]/sum(freqs) (if sum(freqs) != 0)

# As we are only interested in the impact of the mutations on the global population dynamics, we don't care where the mutation come from and only store its effect,
# not its history or parents or ID number




# Output initialisation
Numbers_name = path+folder+dir_name+ final_name + final_name + "_Numbers.csv"  # Name of the CSV file where "numbers" samples will be stored
with open(Numbers_name, "w", newline = "") as csv_file : # creating the file and its header
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(["Generation", "Blue bacteria (invading)","Yellow bacteria (invading)", "Green bacteria (resident)", "Red bacteria (resident)"])
    csv_writer.writerow([0]+numbers)

Poly_name = path+folder+dir_name + final_name + final_name + "_Polymorph.csv"  # Number of different substrains within each of the 4 colors over time, sampled every t_sample generations
# Allows to see quickly the number of competing substrains in each population and can be used as a proxy to check for clonal interference 
# Purely informative (not used to create the heatmap)
with open(Poly_name, "w", newline = "") as csv_file : # creating the file and its header
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(["Generation", "Blue bacteria (invading)","Yellow bacteria (invading)", "Green bacteria (resident)", "Red bacteria (resident)"])
    csv_writer.writerow([0,1,1,1,1])

Mean_fit_name = path+folder+dir_name+ final_name + final_name + "_Mean_fit.csv"  # Mean fitness within each of the 4 colors over time
# It allows to see which population is globally the more fit and predict what would have happened if we had let the simulation run for a longer time 
# Indeed, with this model, one of the 4 colors should wipe out the other 3 in finite time almost surely, but at the time we stop the simulation this may not have happened
# (depending on the parameters and randomness). This file is purely informative (not used to create the heatmap)
with open(Mean_fit_name, "w", newline = "") as csv_file : # creating the file and its header
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(["Generation", "Blue bacteria (invading)","Yellow bacteria (invading)", "Green bacteria (resident)", "Red bacteria (resident)"])
    csv_writer.writerow([0,0,0,0,0])

Tot_mut_name = path+folder+dir_name+ final_name + final_name + "_Tot_mut.csv"  #  Index of total number of mutations that APPEARED for each color (keep increasing at each new mutation)
# It should behave as (mutation rate u)*(sum of color population size accross generations) and is purely informative (not used to create the heatmap)
with open(Tot_mut_name, "w", newline = "") as csv_file : # creating the file and its header
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(["Generation", "Blue bacteria (invading)","Yellow bacteria (invading)", "Green bacteria (resident)", "Red bacteria (resident)", "Total"])
    csv_writer.writerow(["0", "0","0","0","0","0"])




##### Simulations over the generations #####
tot_mut = [0,0,0,0] # keep track of the total number of mutations that appreared for each color

t_loop0 = t.time()

for g in range(1,N_generation+1) : 
    for i in range(4) :  # for the 4 colors
        lam = u*numbers[i]  # lambda of the Poisson law for each color 
        if lam != 0 :
            n_mut = np.random.poisson(lam=lam, size=1)[0]
            
        else : n_mut=0

        l = len(fit_values[i]) # current number of substrains
        for j in range(n_mut) : # for each new mutation
            ancestor_ind = np.random.choice([i for i in range(l)], p=[f/numbers[i] for f in freqs[i]])  # choose the substrain affected,
            # with probability corresponding to the proportion of bacteria of this substrain within the total color population
            tot_mut[i] += 1 # update tot_mut 
            freqs[i][ancestor_ind] -= 1  # update the population size of the substrain affected (loose one individual that has mutated)
            new_s = np.random.gamma(k, scale=theta) # sample the selective effect of the new mutation  
            if freqs[i][ancestor_ind]==0 :  # very rare case when a mutation causes a substrain to go extinct
                freqs[i].pop(ancestor_ind) # I remove the extinct substrain fril the lists
                fit_values[i].pop(ancestor_ind)
                l -= 1  # I update the number of strains
            fit_values[i].append(fit_values[i][ancestor_ind]*(1+new_s)) # add the new substrain created by the new mutation
            # its fitness is equal to the fitness of its parent times (1+new_s)
            freqs[i].append(1) # I add the new substrain  to the list of population sizes within the color
            l += 1  # update the number of substrains
    

    # update the probabilities to make an offspring in the next generation
    sum_fit = 0
    for i in range(4) :
        for w,f in zip(fit_values[i], freqs[i]) :  # compute the total fitness of the population
            sum_fit += f*w # I multiply the fitness of each substrain by its population size and sum other the substrains

    probs = []
    for i in range(4) :
        for w,f in zip(fit_values[i], freqs[i]) :  # compute the fitness for each substrain within each color
            probs.append((f/ sum_fit)*w)

    new_pop = list(np.random.multinomial(int(N_tot), probs, size=1)[0])   # sample the new generation with a multinomial law
    new_freqs = [] # new frequencies
    count = 0  # index of the beginning of a color in the new_pop list
    for i in range(4) : # for each color I take the corresponding numbers in the new population and write them into the new frequency list 
        new_freqs.append(new_pop[count:count+len(freqs[i])])   # I take the individuals for each color
        count += len(freqs[i])
        to_remove = []  # we only keep the mutations still present
        for j,f in enumerate(new_freqs[i]) :  # determine which indexes I have to remove within the color
            if f==0 :
                to_remove.append(j)
        to_remove.reverse()  # always begin by the end when removing or it will change the indexes you want to remove
        for j in to_remove : 
            new_freqs[i].pop(j) 
            fit_values[i].pop(j) 


    freqs = new_freqs # update the frequencies. We don't keep the previous frequencies 

    new_numbers = []
    for i in range(4) :  # compute the new numbers 
        new_numbers.append(sum(freqs[i]))  # sum([]) = 0 
    numbers = new_numbers
                        

    # sample if the generation is a multiple of t_sample
    if g%t_sample==0 :
        with open(Numbers_name, "a", newline = "") as csv_file : # write down the population size of each of the 4 colors
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow([g]+numbers) # g is the generation number (defined in the loop)
        
        # create two lists of 5 with generation number g and then the number of polymorphims or mean number of mutations for each color
        poly = [g]  # number of polymorphisms
        mean_fit = [g] # mean fitness
        for i in range(4) : # for each color
            poly.append(len(freqs[i])) # number of polymorphisms = number of current substrains alive

            mean = 0
            if numbers[i] != 0 : # if the color is not extinct
                for j in range(len(freqs[i])) :
                    prop = freqs[i][j]/numbers[i]
                    mean += fit_values[i][j]*prop   # compute its mean
            mean_fit.append(mean)  # add the mean for this color to the list


        with open(Poly_name, "a", newline = "") as csv_file : # write down the number of current substrains
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow(poly)
        
        
        with open(Mean_fit_name, "a", newline = "") as csv_file : # write down the mean fitness
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow(mean_fit)

        with open(Tot_mut_name, "a", newline = "") as csv_file :  # write down the total number of mutation that appeared for each strain (purely informative)
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow([g]+tot_mut+[sum(tot_mut)])


        if ((numbers[0]==0) and (numbers[1]==0)) and  (folder[:6] != "\Tests") :
            print("STOP : THE TWO INVADING STRAINS WENT EXTINCT")  # the simulation will not be compatible with the data we try to simulate so we stop it now to gain time 
            break  # stops the loop
        
        if int(N_tot) in numbers : 
            print("STOP : ONE STRAIN HAS ELIMINATED ALL THE OTHERS") # the simulation will not be compatible with the data we try to simulate so we stop it now to gain time
            break  # stops the loop




t_loopf = t.time()
print("End of this simulation (rep "+str(rep)+"). It took "+str(t_loopf-t0)+" seconds."+"Average time per generation was " + str((t_loopf-t_loop0)/N_generation))






